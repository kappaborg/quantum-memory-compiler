#!/usr/bin/env python3
"""
Quantum Memory Compiler - Advanced Memory-Aware Quantum Circuit Compilation
Copyright (c) 2025 Quantum Memory Compiler Project

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

This file contains proprietary algorithms for quantum memory optimization.
Commercial use requires explicit permission.
"""

"""
Simulator mod√ºl√º
=============

Kuantum devrelerini sim√ºle eden sƒ±nƒ±f.
"""

import numpy as np
from collections import defaultdict

from ..core.gate import GateType
from .error_mitigation import ErrorMitigation


class Simulator:
    """
    Kuantum devrelerini sim√ºle eden sƒ±nƒ±f
    
    Basit kuantum sim√ºlasyonu i√ßin state-vector yakla≈üƒ±mƒ±nƒ± kullanƒ±r.
    Geli≈ümi≈ü g√ºr√ºlt√º modelleri ve hata azaltma teknikleriyle entegre √ßalƒ±≈üƒ±r.
    """
    
    def __init__(self, noise_model=None, enable_error_mitigation=False):
        """
        Simulator nesnesini ba≈ülatƒ±r
        
        Args:
            noise_model: Sim√ºlasyonda kullanƒ±lacak g√ºr√ºlt√º modeli (opsiyonel)
            enable_error_mitigation: Hata azaltma y√∂ntemlerini etkinle≈ütir
        """
        self.noise_model = noise_model
        self.results = {}
        self.enable_error_mitigation = enable_error_mitigation
        
        # Hata azaltma mod√ºl√º
        if self.enable_error_mitigation:
            self.error_mitigation = ErrorMitigation(self)
        else:
            self.error_mitigation = None
    
    def run(self, circuit, shots=1024, apply_error_mitigation=None):
        """
        Verilen devreyi sim√ºle eder
        
        Args:
            circuit: Sim√ºle edilecek devre
            shots: Sim√ºlasyon tekrar sayƒ±sƒ±
            apply_error_mitigation: Hata azaltma uygula (None: varsayƒ±lan ayarƒ± kullan)
            
        Returns:
            dict: √ñl√ß√ºm sonu√ßlarƒ±
        """
        print(f"üî¨ Simulator.run called with {shots} shots")
        print(f"üî¨ Circuit has {len(circuit.gates)} gates and {len(circuit.qubits)} qubits")
        
        # Hata azaltma ayarƒ±nƒ± belirle
        apply_mitigation = apply_error_mitigation if apply_error_mitigation is not None else self.enable_error_mitigation
        
        # Her shot i√ßin ayrƒ± sim√ºlasyon √ßalƒ±≈ütƒ±r
        counts = defaultdict(int)
        
        for shot_idx in range(shots):
            # Qubit durumlarƒ±nƒ± hazƒ±rla
            qubit_states = {}
            for qubit in circuit.qubits:
                qubit.state.reset()  # |0‚ü© durumuna sƒ±fƒ±rla
                qubit_states[qubit.id] = qubit.state
            
            # Kapƒ±larƒ± zamanlarƒ±na g√∂re sƒ±rala ve uygula
            sorted_gates = sorted(circuit.gates, key=lambda g: g.time)
            
            if shot_idx == 0:  # Sadece ilk shot i√ßin debug
                print(f"üî¨ Processing {len(sorted_gates)} gates")
                for i, gate in enumerate(sorted_gates):
                    print(f"üî¨ Gate {i}: {gate.type.name} on qubits {[q.id for q in gate.qubits]}")
            
            # √ñl√ß√ºm sonu√ßlarƒ±nƒ± sakla
            measurements = {}
            
            # Her kapƒ±yƒ± sƒ±rayla uygula
            for gate_idx, gate in enumerate(sorted_gates):
                # √ñl√ß√ºm kapƒ±sƒ± ise, sonucu kaydet
                if gate.type == GateType.MEASURE:
                    qubit = gate.qubits[0]
                    result = qubit.state.measure()
                    classical_bit = gate.parameters[0] if gate.parameters else qubit.id
                    measurements[classical_bit] = result
                    if shot_idx == 0:
                        print(f"üî¨ Measured qubit {qubit.id} -> {result} (classical bit {classical_bit})")
                
                # Reset kapƒ±sƒ± ise, qubit'i sƒ±fƒ±rla
                elif gate.type == GateType.RESET:
                    qubit = gate.qubits[0]
                    qubit.state.reset()
                    
                # Diƒüer kapƒ±larƒ± uygula
                else:
                    gate_qubits = [qubit_states[q.id] for q in gate.qubits]
                    
                    # G√ºr√ºlt√º modeli varsa, kapƒ±ya g√ºr√ºlt√º ekle
                    if self.noise_model and gate.type != GateType.BARRIER:
                        self.noise_model.apply_noise(gate, gate_qubits, gate.time, gate_idx)
                    
                    # Kapƒ±yƒ± uygula
                    if gate.type != GateType.BARRIER:
                        try:
                            if gate.type == GateType.CNOT:
                                # CNOT kapƒ±sƒ± √∂zel olarak uygulanƒ±yor
                                self._apply_cnot(gate_qubits[0], gate_qubits[1])
                            elif gate.type == GateType.CZ:
                                self._apply_cz(gate_qubits[0], gate_qubits[1])
                            else:
                                gate.apply(gate_qubits)
                        except NotImplementedError:
                            print(f"Uyarƒ±: {gate.type.name} tipi kapƒ± sim√ºlat√∂rde tam olarak desteklenmiyor")
            
            # Bu sim√ºlasyonun sonucunu counts'a ekle
            if measurements:
                # √ñl√ß√ºm sonu√ßlarƒ± varsa, bunlarƒ± kullan
                result_str = ''.join(str(measurements.get(i, 0)) for i in sorted(measurements.keys()))
                if shot_idx == 0:
                    print(f"üî¨ Measurement results: {measurements}")
                    print(f"üî¨ Result string: '{result_str}'")
            else:
                # √ñl√ß√ºm sonu√ßlarƒ± yoksa, t√ºm qubit'lerin son durumlarƒ±nƒ± √∂l√ß
                result_bits = []
                for qubit in circuit.qubits:
                    measurement_result = qubit.state.measure()
                    result_bits.append(str(measurement_result))
                result_str = ''.join(result_bits)
                if shot_idx == 0:
                    print(f"üî¨ No explicit measurements, measuring final states: {result_bits}")
                    print(f"üî¨ Result string: '{result_str}'")
            
            if result_str:
                counts[result_str] += 1
        
        print(f"üî¨ Final counts: {dict(counts)}")
        
        # Sonu√ßlarƒ± normalize et
        results = {}
        for key in counts:
            results[key] = counts[key] / shots
        
        print(f"üî¨ Normalized results: {results}")
        
        self.results = dict(results)
        
        # Hata azaltma uygula
        if apply_mitigation and self.error_mitigation:
            try:
                # √ñl√ß√ºm hatasƒ± azaltma uygula
                if hasattr(self.noise_model, 'active_mitigations') and "measurement_error_mitigation" in self.noise_model.active_mitigations:
                    mitigated_results = self.error_mitigation.apply_measurement_error_mitigation(
                        self.results, 
                        circuit.width
                    )
                    self.results = mitigated_results
            except Exception as e:
                print(f"Hata azaltma uygulanƒ±rken hata olu≈ütu: {e}")
        
        # Return the results directly - use local results if no mitigation applied
        final_results = self.results if (apply_mitigation and self.error_mitigation) else results
        print(f"üî¨ Final results to return: {final_results}")
        return final_results
    
    def run_with_error_mitigation(self, circuit, shots=1024, technique="measurement_error_mitigation"):
        """
        Belirtilen hata azaltma tekniƒüi ile devreyi sim√ºle eder
        
        Args:
            circuit: Sim√ºle edilecek devre
            shots: Sim√ºlasyon tekrar sayƒ±sƒ±
            technique: Kullanƒ±lacak hata azaltma tekniƒüi
                      ("measurement_error_mitigation", "zne", "richardson", "pec")
            
        Returns:
            dict: Hata azaltma uygulanmƒ±≈ü √∂l√ß√ºm sonu√ßlarƒ±
        """
        if not self.error_mitigation:
            self.error_mitigation = ErrorMitigation(self)
        
        if not self.noise_model:
            print("Uyarƒ±: Hata azaltma i√ßin g√ºr√ºlt√º modeli gereklidir")
            return self.run(circuit, shots)
        
        # √ñnce √∂l√ß√ºm hatasƒ± kalibrasyonu yap (gerekirse)
        if technique == "measurement_error_mitigation" and not self.error_mitigation.calibration_data:
            self.error_mitigation.calibrate_measurement_errors(circuit, shots=shots)
            self.noise_model.enable_error_mitigation(technique)
        
        # ZNE i√ßin g√∂zlemlenebilir fonksiyon
        if technique == "zne":
            self.noise_model.enable_error_mitigation(technique)
            
            # Basit beklenen deƒüer hesaplama fonksiyonu - farklƒ± problem i√ßin √∂zelle≈ütirilebilir
            def expectation_z(results):
                # |0> durumu i√ßin +1, |1> durumu i√ßin -1 deƒüeri ver
                exp_val = 0
                for bitstring, prob in results.items():
                    # Tek qubit durumu i√ßin basit hesaplama (√ßoklu qubit i√ßin geni≈ületilebilir)
                    if len(bitstring) == 1:
                        exp_val += prob * (1 if bitstring == '0' else -1)
                    else:
                        # √áoklu qubit i√ßin ilk qubit'i dikkate al
                        exp_val += prob * (1 if bitstring[0] == '0' else -1)
                return exp_val
            
            mitigated_value = self.error_mitigation.zero_noise_extrapolation(
                circuit, expectation_z, shots
            )
            # ZNE yalnƒ±zca beklenen deƒüer d√∂nd√ºr√ºr, bunu sonu√ß formatƒ±na d√∂n√º≈üt√ºr
            return {"ZNE_expectation_value": mitigated_value}
        
        # Richardson ekstrapolasyonu
        elif technique == "richardson":
            # Basit beklenen deƒüer hesaplama fonksiyonu
            def expectation_z(results):
                exp_val = 0
                for bitstring, prob in results.items():
                    if len(bitstring) == 1:
                        exp_val += prob * (1 if bitstring == '0' else -1)
                    else:
                        exp_val += prob * (1 if bitstring[0] == '0' else -1)
                return exp_val
            
            mitigated_value = self.error_mitigation.richardson_extrapolation(
                circuit, expectation_z, shots
            )
            return {"Richardson_expectation_value": mitigated_value}
        
        # PEC (Probabilistic Error Cancellation)
        elif technique == "pec":
            mitigated_results = self.error_mitigation.probabilistic_error_cancellation(
                circuit, shots
            )
            return mitigated_results
        
        # Varsayƒ±lan: normal sim√ºlasyon ve sonra mitigation
        else:
            self.noise_model.enable_error_mitigation(technique)
            results = self.run(circuit, shots, apply_error_mitigation=True)
            return results
    
    def _apply_cnot(self, control_state, target_state):
        """
        CNOT kapƒ±sƒ±nƒ± uygular
        
        Args:
            control_state: Kontrol qubit durumu
            target_state: Hedef qubit durumu
        """
        # Kontrol qubit'i |1‚ü© durumundaysa, hedef qubit'i √ßevir
        if abs(control_state.beta) > 0.5:  # |1‚ü© durumuna daha yakƒ±n
            # X kapƒ±sƒ± uygula
            alpha, beta = target_state.alpha, target_state.beta
            target_state.alpha = beta
            target_state.beta = alpha
    
    def _apply_cz(self, control_state, target_state):
        """
        CZ kapƒ±sƒ± uygular: |11> durumunda hedef qubit'in fazƒ±nƒ± √ßevirir
        """
        # |11> durumunda hedef qubit'in fazƒ±nƒ± √ßevir
        # QubitState: alpha|0> + beta|1>
        # CZ: |11> -> -|11>
        # Sadece target_state.beta'ya -1 √ßarpanƒ± uygula
        # (Bu basit modelde, iki qubitin de |1> olmasƒ± durumunda faz √ßevirme yapƒ±lƒ±r)
        if abs(control_state.beta) > 0.5 and abs(target_state.beta) > 0.5:
            target_state.beta *= -1
    
    def get_statevector(self, circuit):
        """
        Verilen devrenin durum vekt√∂r√ºn√º hesaplar
        
        Not: Bu basit implementasyon tam bir state vector sim√ºlat√∂r√º deƒüildir.
        Ger√ßek bir sim√ºlat√∂r, t√ºm qubit'lerin birle≈üik durumunu temsil eden 
        2^n boyutunda bir durum vekt√∂r√º kullanƒ±r.
        
        Args:
            circuit: Sim√ºle edilecek devre
            
        Returns:
            dict: Her qubit i√ßin ayrƒ± durum vekt√∂rleri
        """
        # Qubit durumlarƒ±nƒ± hazƒ±rla
        qubit_states = {}
        for qubit in circuit.qubits:
            qubit.state.reset()  # |0‚ü© durumuna sƒ±fƒ±rla
            qubit_states[qubit.id] = qubit.state
        
        # Kapƒ±larƒ± zamanlarƒ±na g√∂re sƒ±rala ve uygula
        sorted_gates = sorted(circuit.gates, key=lambda g: g.time)
        
        # Her kapƒ±yƒ± sƒ±rayla uygula
        for gate_idx, gate in enumerate(sorted_gates):
            if gate.type != GateType.BARRIER and gate.type != GateType.MEASURE:
                gate_qubits = [qubit_states[q.id] for q in gate.qubits]
                try:
                    if gate.type == GateType.CNOT:
                        # CNOT kapƒ±sƒ± √∂zel olarak uygulanƒ±yor
                        self._apply_cnot(gate_qubits[0], gate_qubits[1])
                    elif gate.type == GateType.CZ:
                        self._apply_cz(gate_qubits[0], gate_qubits[1])
                    else:
                        gate.apply(gate_qubits)
                        
                    # G√ºr√ºlt√º modeli varsa ve etkinse, statevector'a da g√ºr√ºlt√º uygula
                    if self.noise_model:
                        self.noise_model.apply_noise(gate, gate_qubits, gate.time, gate_idx)
                except NotImplementedError:
                    print(f"Uyarƒ±: {gate.type.name} tipi kapƒ± sim√ºlat√∂rde tam olarak desteklenmiyor")
        
        # Her qubit i√ßin durum vekt√∂r√ºn√º d√∂nd√ºr
        state_vectors = {}
        for qubit_id, state in qubit_states.items():
            state_vectors[qubit_id] = state.to_vector()
        
        return state_vectors
    
    def get_last_results(self):
        """
        Son √ßalƒ±≈ütƒ±rƒ±lan sim√ºlasyonun sonu√ßlarƒ±nƒ± d√∂nd√ºr√ºr
        
        Returns:
            dict: √ñl√ß√ºm sonu√ßlarƒ±
        """
        return self.results
    
    def simulate_with_multiple_noise_levels(self, circuit, shots=1024, noise_scales=[0.5, 1.0, 2.0]):
        """
        Farklƒ± g√ºr√ºlt√º seviyelerinde sim√ºlasyon √ßalƒ±≈ütƒ±rƒ±r
        
        Args:
            circuit: Sim√ºle edilecek devre
            shots: Sim√ºlasyon tekrar sayƒ±sƒ±
            noise_scales: G√ºr√ºlt√º √∂l√ßekleme fakt√∂rleri
            
        Returns:
            dict: Farklƒ± g√ºr√ºlt√º seviyelerindeki sim√ºlasyon sonu√ßlarƒ±
        """
        if not self.noise_model:
            raise ValueError("Bu √∂zellik i√ßin g√ºr√ºlt√º modeli gereklidir")
            
        multi_results = {}
        
        # Orijinal g√ºr√ºlt√º modelini yedekle
        original_noise_model = self.noise_model
        
        for scale in noise_scales:
            # G√ºr√ºlt√º modelinin kopyasƒ±nƒ± olu≈ütur
            import copy
            temp_noise_model = copy.deepcopy(original_noise_model)
            
            # G√ºr√ºlt√º parametrelerini √∂l√ßekle
            for attr_name in ["depolarizing_prob", "bit_flip_prob", "phase_flip_prob", 
                             "amplitude_damping_prob", "thermal_relaxation_prob"]:
                if hasattr(temp_noise_model, attr_name):
                    setattr(temp_noise_model, attr_name, 
                            getattr(temp_noise_model, attr_name) * scale)
            
            # Kapƒ± hata oranlarƒ±nƒ± da √∂l√ßekle
            for gate_type in temp_noise_model.gate_error_rates:
                temp_noise_model.gate_error_rates[gate_type] *= scale
            
            # √ñl√ßeklenmi≈ü modeli kullan
            self.noise_model = temp_noise_model
            
            # Sim√ºlasyonu √ßalƒ±≈ütƒ±r
            results = self.run(circuit, shots)
            multi_results[f"scale_{scale}"] = results
        
        # Orijinal g√ºr√ºlt√º modelini geri y√ºkle
        self.noise_model = original_noise_model
        
        return multi_results 